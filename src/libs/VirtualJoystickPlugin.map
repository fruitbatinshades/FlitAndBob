{"version":3,"sources":["const.js","../../node_modules/eventemitter3/index.js","Button.js","BaseStick.js","DPad.js","Stick.js","HiddenStick.js","VirtualJoystickPlugin.js"],"names":["CONST","NONE","HORIZONTAL","VERTICAL","CIRC_BUTTON","RECT_BUTTON","module","exports","Button","scene","shape","x","y","texture","upFrame","downFrame","sprite","add","hitArea","Phaser","Geom","Circle","width","Rectangle","height","pointer","enabled","isDown","isUp","timeDown","timeUp","name","currentTime","repeatRate","key","_timeNext","_scale","input","sys","on","checkDown","checkUp","keyboard","off","keyDown","keyUp","removeKey","addKey","setFrame","emit","duration","contains","worldX","worldY","time","spacing","w","h","posX","posY","scale","rate","destroy","removeAllListeners","alpha","value","visible","setScale","setTo","EventEmitter","BaseStick","distance","position","Math","Vector2","line","Line","baseHitArea","stickHitArea","baseSprite","stickSprite","limitPoint","angle","angleFull","direction","quadrant","octant","motionLock","_distance","_deadZone","_tracking","_showOnTouch","moveStick","x2","y2","x1","y1","setDown","Length","deadZone","setPosition","checkArea","RadToDeg","Angle","DOWN","LEFT","UP","RIGHT","round","lineLength","lineAngle","radius","CircumferencePoint","force","forceX","forceY","displayWidth","displayHeight","graphics","text","clear","lineStyle","strokeCircleShape","strokeLineShape","setText","toFixed","rotation","pi","PI","tau","TAU","abs","min","fx","fy","setAlpha","setVisible","stickWidth","DPad","size","neutralFrame","leftFrame","rightFrame","_directions","_lastDirection","substr","Stick","baseFrame","stickFrame","HiddenStick","VirtualJoystick","pluginManager","game","systems","sticks","buttons","_pointerTotal","events","once","boot","settings","active","start","Set","update","shutdown","stick","addPointer","remove","button","Array","isArray","b","eventEmitter"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAIA,KAAK,GAAG;AAER;;;;;AAKAC,EAAAA,IAAI,EAAE,CAPE;;AASR;;;;;AAKAC,EAAAA,UAAU,EAAE,CAdJ;;AAgBR;;;;;AAKAC,EAAAA,QAAQ,EAAE,CArBF;;AAuBR;;;;;AAKAC,EAAAA,WAAW,EAAE,CA5BL;;AA8BR;;;;;AAKAC,EAAAA,WAAW,EAAE;AAnCL,CAAZ;AAuCAC,MAAM,CAACC,OAAP,GAAiBP,KAAjB;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1UA;;AACA;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;IAWaQ;;;;;AAET;;;;;;;;;AASA,kBAAaC,KAAb,EAAoBC,KAApB,EAA2BC,CAA3B,EAA8BC,CAA9B,EAAiCC,OAAjC,EAA0CC,OAA1C,EAAmDC,SAAnD,EACA;AAAA;;AAAA;;AACI;AAEA;;;;;AAIA,UAAKN,KAAL,GAAaA,KAAb;AAEA;;;;;AAIA,UAAKK,OAAL,GAAeA,OAAf;AAEA;;;;;AAIA,UAAKC,SAAL,GAAiBA,SAAjB;AAEA;;;;;AAIA,UAAKC,MAAL,GAAc,MAAKP,KAAL,CAAWQ,G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","file":"VirtualJoystickPlugin.map","sourceRoot":"..\\..\\virtual-joystick\\src","sourcesContent":["let CONST = {\r\n\r\n    /**\r\n    * Used by the motionLock method. Defines full freedom of movement.\r\n    * @constant\r\n    * @type {integer}\r\n    */\r\n    NONE: 0,\r\n\r\n    /**\r\n    * Used by the motionLock method. Defines movement locked to the horizontal axis only.\r\n    * @constant\r\n    * @type {integer}\r\n    */\r\n    HORIZONTAL: 1,\r\n\r\n    /**\r\n    * Used by the motionLock method. Defines movement locked to the vertical axis only.\r\n    * @constant\r\n    * @type {integer}\r\n    */\r\n    VERTICAL: 2,\r\n\r\n    /**\r\n    * Used by Button.shape. Defines the hit area geometry shape being used is a Circle.\r\n    * @constant\r\n    * @type {integer}\r\n    */\r\n    CIRC_BUTTON: 3,\r\n\r\n    /**\r\n    * Used by Button.shape. Defines the hit area geometry shape being used is a Rectangle.\r\n    * @constant\r\n    * @type {integer}\r\n    */\r\n    RECT_BUTTON: 4\r\n\r\n}\r\n\r\nmodule.exports = CONST;\r\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","/**\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2019 Photon Storm Ltd.\r\n* @license      {@link http://choosealicense.com/licenses/no-license/|No License}\r\n*/\r\n\r\nimport CONST from './const';\r\nimport EventEmitter from 'eventemitter3';\r\n\r\n/**\r\n * A `Button` is a virtual button. It belongs to the Virtual Joystick Plugin which is responsible for creating and updating it.\r\n *\r\n * Create a new button by using the `VirtualJoystickPlugin.addButton` method.\r\n * \r\n * It consists of one sprite with two frames. One frame depicts the button as it's held down, the other when up.\r\n *\r\n * The Button is digital, i.e. it is either 'on or off'. It doesn't have a pressure or force associated with it.\r\n * \r\n * The Button sprites are automatically added to the Scene at the point this Button is created.\r\n */\r\nexport class Button extends EventEmitter\r\n{\r\n    /**\r\n     * @param {Phaser.Scene} scene - A reference to the Scene this stick was created in.\r\n     * @param {integer} shape - The shape of the buttons hit area. Either `VirtualJoystickPlugin.CIRC_BUTTON` or `VirtualJoystickPlugin.RECT_BUTTON`.\r\n     * @param {number} x - The x coordinate to draw the button at. The button is centered on this coordinate.\r\n     * @param {number} y - The y coordinate to draw the button at. The button is centered on this coordinate.\r\n     * @param {string} texture - The key of the texture atlas to be used to render this button.\r\n     * @param {string} upFrame - The name of the frame within the button texture atlas to be used when the button is in an 'up' state.\r\n     * @param {string} downFrame - The name of the frame within the button texture atlas to be used when the button is in a 'down' state.\r\n     */\r\n    constructor (scene, shape, x, y, texture, upFrame, downFrame)\r\n    {\r\n        super();\r\n\r\n        /**\r\n         * A reference to the Scene this stick was created in.\r\n         * @type {Phaser.Scene}\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The name of the frame within the button texture atlas to be used when the button is in an 'up' state.\r\n         * @type {string}\r\n         */\r\n        this.upFrame = upFrame;\r\n\r\n        /**\r\n         * The name of the frame within the button texture atlas to be used when the button is in a 'down' state.\r\n         * @type {string}\r\n         */\r\n        this.downFrame = downFrame;\r\n\r\n        /**\r\n         * The Sprite that is used to display this button.\r\n         * @type {Phaser.GameObjects.Sprite}\r\n         */\r\n        this.sprite = this.scene.add.sprite(x, y, texture, upFrame);\r\n\r\n        /**\r\n         * The hit area of the button in which input events will be detected.\r\n         * @type {Phaser.Geom.Circle|Phaser.Geom.Rectangle} hitArea\r\n         */\r\n        if (shape === CONST.CIRC_BUTTON)\r\n        {\r\n            this.hitArea = new Phaser.Geom.Circle(this.sprite.x, this.sprite.y, this.sprite.width / 2);\r\n        }\r\n        else if (shape === CONST.RECT_BUTTON)\r\n        {\r\n            this.hitArea = new Phaser.Geom.Rectangle(this.sprite.x, this.sprite.y, this.sprite.width, this.sprite.height);\r\n        }\r\n\r\n        /**\r\n         * A reference to the Input Pointer being used to update this button.\r\n         * @type {Phaser.Input.Pointer}\r\n         */\r\n        this.pointer = null;\r\n\r\n        /**\r\n         * Should this button process or dispatch any events? Set to `false` to disable it.\r\n         * @type {boolean}\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * The current down state of this button. A button is determined as being down if it has been pressed.\r\n         * @type {boolean}\r\n         */\r\n        this.isDown = false;\r\n\r\n        /**\r\n         * The current up state of this button. A button is determined as being up if it is not being pressed.\r\n         * @type {boolean}\r\n         */\r\n        this.isUp = true;\r\n\r\n        /**\r\n         * The time when the button last entered an `isDown` state.\r\n         * @type {integer}\r\n         */\r\n        this.timeDown = 0;\r\n\r\n        /**\r\n         * The time when the button last entered an `isUp` state.\r\n         * @type {integer}\r\n         */\r\n        this.timeUp = 0;\r\n\r\n        /**\r\n         * A name for this Button. This property is never used by Phaser, so you are free to set it to whatever\r\n         * your game requires.\r\n         * @type {string}\r\n         */\r\n        this.name = '';\r\n\r\n        /**\r\n         * The current time, as set by the plugin each frame.\r\n         * @type {integer}\r\n         */\r\n        this.currentTime = 0;\r\n\r\n        /**\r\n         * The `repeatRate` allows you to set how often this button fires the `ButtonDownEvent`.\r\n         * \r\n         * At the default setting of zero the onDown event will be sent only once and no further events\r\n         * will be sent until the button is released and pressed again.\r\n         *\r\n         * By setting `repeatRate` to a value above zero you can control the time delay in milliseconds between each event.\r\n         *\r\n         * For example: `button.repeatRate = 100` would send the event once every 100ms for as long as the button is held down.\r\n         *\r\n         * To disable a repeat rate set the value back to zero again.\r\n         * \r\n         * @type {integer}\r\n         */\r\n        this.repeatRate = 0;\r\n\r\n        /**\r\n         * The key that is bound to this button. Pressing it activates the button the same way as clicking does.\r\n         * It is set via `Button.addKey`.\r\n         * \r\n         * @type {?Phaser.Input.Keyboard.Key}\r\n         */\r\n        this.key = null;\r\n\r\n        /**\r\n         * Internal calculation var.\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._timeNext = 0;\r\n\r\n        /**\r\n         * Internal calculation var.\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._scale = 1;\r\n\r\n        const input = this.scene.sys.input;\r\n\r\n        input.on('pointerdown', this.checkDown, this);\r\n        input.on('pointerup', this.checkUp, this);\r\n    }\r\n\r\n    /**\r\n     * You can bind a Keyboard key to this button, so that when the key is pressed the button is activated.\r\n     *\r\n     * Obviously you only want to do this on desktop browsers, but it allows you to minimize your code quantity.\r\n     *\r\n     * When the Key is pressed the Button.onDown event is dispatched.\r\n     * \r\n     * The given argument can be either an existing Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     *\r\n     * If a Key object is given, and one already exists matching the same key code, the existing one is replaced with the new one.\r\n     *\r\n     * @param {(Phaser.Input.Keyboard.Key|string|integer)} key - Either a Key object, a string, such as `A` or `SPACE`, or a key code value.\r\n     * \r\n     * @return {Phaser.Input.Keyboard.Key} The newly created Key object, or a reference to it if it already existed in the keys array.\r\n     */\r\n    addKey (key)\r\n    {\r\n        const input = this.scene.sys.input;\r\n\r\n        if (input.keyboard)\r\n        {\r\n            if (this.key)\r\n            {\r\n                this.key.off('down', this.keyDown, this);\r\n                this.key.off('up', this.keyUp, this);\r\n        \r\n                input.keyboard.removeKey(this.key);\r\n    \r\n                this.key = null;\r\n            }\r\n\r\n            this.key = input.keyboard.addKey(key);\r\n\r\n            this.key.on('down', this.keyDown, this);\r\n            this.key.on('up', this.keyUp, this);\r\n        }\r\n\r\n        return this.key;\r\n    }\r\n\r\n    /**\r\n     * The Key.onDown callback. Processes the down event for this button.\r\n     *\r\n     * @private\r\n     * @fires {ButtonDownEvent}\r\n     */\r\n    keyDown ()\r\n    {\r\n        if (!this.isDown)\r\n        {\r\n            this.sprite.setFrame(this.downFrame);\r\n\r\n            this.isDown = true;\r\n            this.isUp = false;\r\n            this.timeDown = this.key.timeDown;\r\n            this.timeUp = 0;\r\n\r\n            this.emit('down', this, this.key);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Key.onUp callback. Processes the down event for this button.\r\n     *\r\n     * @private\r\n     * @fires {ButtonUpEvent}\r\n     */\r\n    keyUp ()\r\n    {\r\n        if (this.isDown)\r\n        {\r\n            this.sprite.setFrame(this.upFrame);\r\n\r\n            this.isDown = false;\r\n            this.isUp = true;\r\n\r\n            this.timeUp = this.key.timeUp;\r\n\r\n            this.emit('up', this, this.key, this.duration);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Input.onDown callback. Processes the down event for this button.\r\n     *\r\n     * @private\r\n     * @fires {ButtonDownEvent}\r\n     * \r\n     * @param {Phaser.Input.Pointer} pointer - The Phaser Pointer that triggered the event.\r\n     */\r\n    checkDown (pointer)\r\n    {\r\n        if (this.enabled && this.isUp && this.hitArea.contains(pointer.worldX, pointer.worldY))\r\n        {\r\n            this.pointer = pointer;\r\n\r\n            this.sprite.setFrame(this.downFrame);\r\n\r\n            this.isDown = true;\r\n            this.isUp = false;\r\n\r\n            this.timeDown = pointer.time;\r\n            this.timeUp = 0;\r\n\r\n            this.emit('down', this, pointer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Input.onUp callback. Processes the up event for this button.\r\n     *\r\n     * @private\r\n     * @fires {ButtonUpEvent}\r\n     * \r\n     * @param {Phaser.Input.Pointer} pointer - The Phaser Pointer that triggered the event.\r\n     */\r\n    checkUp (pointer)\r\n    {\r\n        if (pointer === this.pointer)\r\n        {\r\n            this.pointer = null;\r\n            this.sprite.setFrame(this.upFrame);\r\n\r\n            this.isDown = false;\r\n            this.isUp = true;\r\n\r\n            this.timeUp = pointer.time;\r\n\r\n            this.emit('up', this, pointer, this.duration);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The update callback. This is called automatically by the Virtual Joystick Plugin.\r\n     *\r\n     * @private\r\n     * @fires {ButtonDownEvent}\r\n     * \r\n     * @param {integer} time - The current time.\r\n     */\r\n    update (time)\r\n    {\r\n        this.currentTime = time;\r\n\r\n        if (this.repeatRate > 0 && this.isDown && time >= this._timeNext)\r\n        {\r\n            this.emit('down', this, this.pointer);\r\n\r\n            this._timeNext = time + this.repeatRate;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visually aligns the button to the bottom left of the game view.\r\n     * The optional spacing parameter allows you to add a border between the edge of the game and the button.\r\n     *\r\n     * @param {number} [spacing=0] - The spacing to apply between the edge of the game and the button.\r\n     * \r\n     * @return {Button} This button instance.\r\n     */\r\n    alignBottomLeft (spacing = 0)\r\n    {\r\n        const w = (this.sprite.width / 2) + spacing;\r\n        const h = (this.sprite.height / 2) + spacing;\r\n\r\n        this.posX = w;\r\n        this.posY = this.scene.sys.scale.height - h;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Visually aligns the button to the bottom right of the game view.\r\n     * The optional spacing parameter allows you to add a border between the edge of the game and the button.\r\n     *\r\n     * @param {number} [spacing=0] - The spacing to apply between the edge of the game and the button.\r\n     * \r\n     * @return {Button} This button instance.\r\n     */\r\n    alignBottomRight (spacing = 0)\r\n    {\r\n        const w = (this.sprite.width / 2) + spacing;\r\n        const h = (this.sprite.height / 2) + spacing;\r\n\r\n        this.posX = this.scene.sys.scale.width - w;\r\n        this.posY = this.scene.sys.scale.height - h;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * The `repeatRate` allows you to set how often the DPad fires the direction events.\r\n     * \r\n     * At the default setting of zero the events will be sent only once and no further events\r\n     * will be sent until the DPad changes direction.\r\n     *\r\n     * By setting `repeatRate` to a value above zero you can control the time delay in milliseconds between each event.\r\n     *\r\n     * For example: `repeatRate = 100` would send the event once every 100ms for as long as\r\n     * the button is held down in the same direction.\r\n     *\r\n     * To disable a repeat rate set the value back to zero again.\r\n     *\r\n     * @param {integer} [rate=0] - The repeat rate.\r\n     * \r\n     * @return {Button} This button instance.\r\n     */\r\n    setRepeatRate (rate = 0)\r\n    {\r\n        this.repeatRate = rate;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a name for this Button.\r\n     * \r\n     * @param {string} [name] - The name for this button.\r\n     * \r\n     * @return {Button} This button instance.\r\n     */\r\n    setName (name = '')\r\n    {\r\n        this.name = name;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Destroys this Button.\r\n     * \r\n     * Removes all associated listeners and events and calls destroy on the button sprite.\r\n     */\r\n    destroy ()\r\n    {\r\n        const input = this.scene.sys.input;\r\n\r\n        input.off('pointerdown', this.checkDown, this);\r\n        input.off('pointerup', this.checkUp, this);\r\n\r\n        this.sprite.destroy();\r\n\r\n        if (this.key)\r\n        {\r\n            this.key.off('down', this.keyDown, this);\r\n            this.key.off('up', this.keyUp, this);\r\n    \r\n            input.keyboard.removeKey(this.key);\r\n\r\n            this.key.destroy();\r\n\r\n            this.key = null;\r\n        }\r\n\r\n        this.removeAllListeners();\r\n\r\n        this.hitArea = null;\r\n        this.pointer = null;\r\n        this.scene = null;\r\n    }\r\n\r\n    /**\r\n     * The x coordinate the button is rendered at. Value should be given in pixel coordinates based on game dimensions.\r\n     * Use this to change the position of the button on-screen. Value can even be tweened to display or hide the button in interesting ways.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get posX ()\r\n    {\r\n        return this.sprite.x;\r\n    }\r\n\r\n    /**\r\n     * The x coordinate the button is rendered at. Value should be given in pixel coordinates based on game dimensions.\r\n     * Use this to change the position of the button on-screen. Value can even be tweened to display or hide the button in interesting ways.\r\n     * \r\n     * @type {number}\r\n     */\r\n    set posX (x)\r\n    {\r\n        this.sprite.x = x;\r\n        this.hitArea.x = x;\r\n    }\r\n\r\n    /**\r\n     * The y coordinate the button is rendered at. Value should be given in pixel coordinates based on game dimensions.\r\n     * Use this to change the position of the button on-screen. Value can even be tweened to display or hide the button in interesting ways.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get posY ()\r\n    {\r\n        return this.sprite.y;\r\n    }\r\n\r\n    /**\r\n     * The y coordinate the button is rendered at. Value should be given in pixel coordinates based on game dimensions.\r\n     * Use this to change the position of the button on-screen. Value can even be tweened to display or hide the button in interesting ways.\r\n     * \r\n     * @type {number}\r\n     */\r\n    set posY (y)\r\n    {\r\n        this.sprite.y = y;\r\n        this.hitArea.y = y;\r\n    }\r\n\r\n    /**\r\n     * The alpha value of the Button.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get alpha ()\r\n    {\r\n        return this.sprite.alpha;\r\n    }\r\n\r\n    /**\r\n     * The alpha value of the Button.\r\n     * \r\n     * Adjusting this value changes the alpha property of button sprite.\r\n     * \r\n     * @type {number}\r\n     */\r\n    set alpha (value)\r\n    {\r\n        this.sprite.alpha = value;\r\n    }\r\n\r\n    /**\r\n     * The visible state of the Button.\r\n     * \r\n     * Adjusting this value changes the visible property of the button sprite.\r\n     *\r\n     * Note that this button will carry on processing and dispatching events even when not visible.\r\n     * If you wish to disable the button from processing events see `Button.enabled`.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get visible ()\r\n    {\r\n        return this.sprite.visible;\r\n    }\r\n\r\n    /**\r\n     * The visible state of the Button.\r\n     * \r\n     * Adjusting this value changes the visible property of the button sprite.\r\n     *\r\n     * Note that this button will carry on processing and dispatching events even when not visible.\r\n     * If you wish to disable the button from processing events see `Button.enabled`.\r\n     * \r\n     * @type {number}\r\n     */\r\n    set visible (value)\r\n    {\r\n        this.sprite.visible = value;\r\n    }\r\n\r\n    /**\r\n    * The scale of the Button. The scale is applied evenly to both the x and y axis of the Button.\r\n    * You cannot specify a different scale per axis.\r\n    * \r\n    * @type {number}\r\n    */\r\n    get scale ()\r\n    {\r\n        return this._scale;\r\n    }\r\n\r\n    /**\r\n    * The scale of the Button. The scale is applied evenly to both the x and y axis of the Button.\r\n    * You cannot specify a different scale per axis.\r\n    * \r\n    * Adjusting this value changes the scale of the button sprite and recalculates the hit area.\r\n    * \r\n    * @type {number}\r\n    */\r\n    set scale (value)\r\n    {\r\n        this.sprite.setScale(value);\r\n\r\n        this.hitArea.setTo(this.sprite.x, this.sprite.y, this.sprite.width);\r\n\r\n        this._scale = value;\r\n    }\r\n\r\n    /**\r\n     * The duration in milliseconds that the Button has been held down for.\r\n     * \r\n     * If the button is not currently in an `onDown` state it returns the duration the button was previously held down for.\r\n     * \r\n     * If the button is in an `onDown` state it returns the current duration in ms.\r\n     * \r\n     * @type {integer}\r\n     */\r\n    get duration ()\r\n    {\r\n        if (this.isUp)\r\n        {\r\n            return this.timeUp - this.timeDown;\r\n        }\r\n        else\r\n        {\r\n            return this.currentTime - this.timeDown;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The ButtonDown event is dispatched as soon as the button is touched, or clicked when under mouse emulation.\r\n * \r\n * If you have added a Key to this button via `addKey` and that is pressed, the event will send the Key as the second\r\n * parameter instead of a Pointer object.\r\n * \r\n * Listen to this event from a button instance:\r\n * \r\n * ```javascript\r\n * const button = this.pad.addButton(...);\r\n * button.on('down', handler);\r\n * ```\r\n * \r\n * @typedef {Object} ButtonDownEvent\r\n * @property {Button} button\r\n * @property {Phaser.Input.Pointer|Phaser.Input.Keyboard.Key} source\r\n */\r\n\r\n/**\r\n * The ButtonUp event is dispatched as soon as the button is released.\r\n * \r\n * If you have added a Key to this button via `addKey`, and that was released, the event will send the Key as the second\r\n * parameter instead of a Pointer object.\r\n * \r\n * It will also send the duration in milliseconds that the button was held down for prior to release.\r\n * \r\n * Listen to this event from a button instance:\r\n * \r\n * ```javascript\r\n * const button = this.pad.addButton(...);\r\n * button.on('up', handler);\r\n * ```\r\n * \r\n * @typedef {Object} ButtonUpEvent\r\n * @property {Button} button\r\n * @property {Phaser.Input.Pointer|Phaser.Input.Keyboard.Key} source\r\n * @property {integer} duration\r\n */\r\n\r\nmodule.exports = Button;\r\n","/**\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2019 Photon Storm Ltd.\r\n* @license      {@link http://choosealicense.com/licenses/no-license/|No License}\r\n*/\r\n\r\nimport CONST from './const';\r\nimport EventEmitter from 'eventemitter3';\r\nimport { VirtualJoystick } from './VirtualJoystickPlugin';\r\n\r\n/**\r\n * A `BaseStick` is the base virtual joystick class that all other types of stick extend from.\r\n */\r\nexport class BaseStick extends EventEmitter\r\n{\r\n    /**\r\n     * @param {Phaser.Scene} scene - A reference to the Scene this stick was created in.\r\n     * @param {number} x - The x coordinate to draw the joystick at. The joystick is centered on this coordinate.\r\n     * @param {number} y - The y coordinate to draw the joystick at. The joystick is centered on this coordinate.\r\n     * @param {number} distance - The distance threshold between the stick and the base. This is how far the stick can be pushed in any direction.\r\n     */\r\n    constructor (scene, x, y, distance)\r\n    {\r\n        super();\r\n\r\n        /**\r\n         * A reference to the Scene this stick was created in.\r\n         * @type {Phaser.Scene}\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * The position of the joystick in screen coordinates. To adjust please use `posX` and `posY`.\r\n         * @type {Phaser.Math.Vector2}\r\n         */\r\n        this.position = new Phaser.Math.Vector2(x, y);\r\n\r\n        /**\r\n         * The line object used for stick to base calculations.\r\n         * @type {Phaser.Geom.Line}\r\n         */\r\n        this.line = new Phaser.Geom.Line(x, y, x, y);\r\n\r\n        /**\r\n         * The circular hit area that defines the base of the joystick.\r\n         * @type {Phaser.Geom.Circle}\r\n         */\r\n        this.baseHitArea = new Phaser.Geom.Circle(x, y, distance / 2);\r\n\r\n        /**\r\n         * The circular hit area that defines the stick or handle of the joystick.\r\n         * @type {Phaser.Geom.Circle}\r\n         */\r\n        this.stickHitArea = new Phaser.Geom.Circle(x, y, distance / 2);\r\n\r\n        /**\r\n         * The Sprite that is used to display the base of the joystick.\r\n         * @type {?Phaser.GameObjects.Sprite}\r\n         */\r\n        this.baseSprite = null;\r\n\r\n        /**\r\n         * The Sprite that is used to display the stick or handle of the joystick.\r\n         * @type {?Phaser.GameObjects.Sprite}\r\n         */\r\n        this.stickSprite = null;\r\n\r\n        /**\r\n         * A Point object that holds the stick limits.\r\n         * @type {Phaser.Math.Vector2}\r\n         */\r\n        this.limitPoint = new Phaser.Math.Vector2();\r\n\r\n        /**\r\n         * A reference to the Input Pointer being used to update this joystick.\r\n         * @type {Phaser.Input.Pointer}\r\n         */\r\n        this.pointer = null;\r\n\r\n        /**\r\n         * Should this joystick process or dispatch any events? Set to `false` to disable it.\r\n         * @type {boolean}\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * The current down state of this joystick. A joystick is determined as being down if it has been pressed and interacted with.\r\n         * If it has a `deadZone` set then it's not considered as being down unless it has moved beyond the limits of the deadZone.\r\n         * @type {boolean}\r\n         */\r\n        this.isDown = false;\r\n\r\n        /**\r\n         * The current up state of this joystick. A joystick is determined as being up if it is not being interacted with.\r\n         * If it has a `deadZone` set then it's considered as being up until it has moved beyond the limits of the deadZone.\r\n         * @type {boolean}\r\n         */\r\n        this.isUp = true;\r\n\r\n        /**\r\n         * The time when the joystick last entered an `isDown` state.\r\n         * @type {integer}\r\n         */\r\n        this.timeDown = 0;\r\n\r\n        /**\r\n         * The time when the joystick last entered an `isUp` state.\r\n         * @type {integer}\r\n         */\r\n        this.timeUp = 0;\r\n\r\n        /**\r\n         * The angle of the joystick in degrees. From -180 to 180 where zero is right-handed.\r\n         * @type {number}\r\n         */\r\n        this.angle = 0;\r\n\r\n        /**\r\n         * The angle of the joystick in degrees. From 0 to 360 where zero is right-handed.\r\n         * @type {number}\r\n         */\r\n        this.angleFull = 0;\r\n\r\n        /**\r\n         * The 4-way direction the stick is currently pointing, if active.\r\n         * \r\n         * @type {Phaser.NONE|Phaser.LEFT|Phaser.RIGHT|Phaser.UP|Phaser.DOWN}\r\n         */\r\n        this.direction = Phaser.NONE;\r\n\r\n        /**\r\n         * The quadrant the joystick is in.\r\n         * Where 315 to 45 degrees is quadrant 0. \r\n         * 45 to 135 degrees is quadrant 1. \r\n         * 135 to 225 degrees is quadrant 2.\r\n         * 225 to 315 degrees is quadrant 3.\r\n         * @type {integer}\r\n         */\r\n        this.quadrant = 0;\r\n\r\n        /**\r\n         * The nearest octant of the joystick. Where each octant is 360 degrees / 45.\r\n         * @type {integer}\r\n         */\r\n        this.octant = 0;\r\n\r\n        /**\r\n         * A Stick can be motion locked. When locked it can only move along the specified axis.\r\n         * \r\n         * `motionLock = 0` will allow it to move freely.\r\n         * `motionLock = 1` will only allow it to move horizontally.\r\n         * `motionLock = 2` will only allow it to move vertically.\r\n         * @type {VirtualJoystick.NONE|VirtualJoystick.HORIZONTAL|VirtualJoystick.VERTICAL}\r\n         */\r\n        this.motionLock = CONST.NONE;\r\n\r\n        /**\r\n         * Internal calculation var.\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._distance = distance;\r\n\r\n        /**\r\n         * Internal calculation var.\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._deadZone = distance * 0.10;\r\n\r\n        /**\r\n         * Internal calculation var.\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._scale = 1;\r\n\r\n        /**\r\n         * Internal var.\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._tracking = false;\r\n\r\n        /**\r\n         * Internal var.\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._showOnTouch = false;\r\n\r\n        const input = this.scene.sys.input;\r\n\r\n        input.on('pointerdown', this.checkDown, this);\r\n        input.on('pointerup', this.checkUp, this);\r\n        input.on('pointerupoutside', this.checkUp, this);\r\n        input.on('pointermove', this.moveStick, this);\r\n    }\r\n\r\n    /**\r\n     * Processes the down event for this stick, or starts tracking if required.\r\n     * \r\n     * @private\r\n     * \r\n     * @param {Phaser.Input.Pointer} pointer - The Phaser Pointer that triggered the event.\r\n     */\r\n    checkDown (pointer)\r\n    {\r\n        const x = pointer.worldX;\r\n        const y = pointer.worldY;\r\n        const line = this.line;\r\n\r\n        if (this.enabled && this.isUp)\r\n        {\r\n            this.pointer = pointer;\r\n\r\n            if (this.motionLock === CONST.NONE)\r\n            {\r\n                line.x2 = x;\r\n                line.y2 = y;\r\n            }\r\n            else if (this.motionLock === CONST.HORIZONTAL)\r\n            {\r\n                line.x2 = x;\r\n            }\r\n            else if (this.motionLock === CONST.VERTICAL)\r\n            {\r\n                line.y2 = y;\r\n            }\r\n\r\n            if (this._showOnTouch)\r\n            {\r\n                line.x1 = x;\r\n                line.y1 = y;\r\n\r\n                this.posX = x;\r\n                this.posY = y;\r\n                this.visible = true;\r\n\r\n                this.setDown();\r\n                this.moveStick(pointer);\r\n            }\r\n            else\r\n            {\r\n                if (this.stickHitArea.contains(x, y))\r\n                {\r\n                    if (Phaser.Geom.Line.Length(line) <= this.deadZone)\r\n                    {\r\n                        this._tracking = true;\r\n                    }\r\n                    else\r\n                    {\r\n                        this.setDown();\r\n                        this.moveStick(pointer);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes the up event for this stick.\r\n     *\r\n     * @private\r\n     * @emits {UpEvent}\r\n     * \r\n     * @param {Phaser.Input.Pointer} pointer - The Phaser Pointer that triggered the event.\r\n     */\r\n    checkUp (pointer)\r\n    {\r\n        if (pointer === this.pointer)\r\n        {\r\n            this.pointer = null;\r\n\r\n            this.stickHitArea.setPosition(this.position.x, this.position.y);\r\n\r\n            if (this.stickSprite)\r\n            {\r\n                this.stickSprite.setPosition(this.position.x, this.position.y);\r\n            }\r\n\r\n            const line = this.line;\r\n\r\n            line.x2 = line.x1;\r\n            line.y2 = line.y1;\r\n\r\n            this.isDown = false;\r\n            this.isUp = true;\r\n            this.direction = Phaser.NONE;\r\n\r\n            this.timeUp = pointer.time;\r\n\r\n            this.emit('up', this, pointer);\r\n\r\n            if (this._showOnTouch)\r\n            {\r\n                this.visible = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal down handler. Activated either onDown or after tracking if the stick has a dead zone.\r\n     *\r\n     * @private\r\n     * @emits {DownEvent}\r\n     */\r\n    setDown ()\r\n    {\r\n        this.isDown = true;\r\n        this.isUp = false;\r\n        this.timeDown = this.pointer.time;\r\n        this.timeUp = 0;\r\n\r\n        this._tracking = false;\r\n\r\n        this.checkArea();\r\n\r\n        this.emit('down', this, this.pointer);\r\n    }\r\n\r\n    /**\r\n     * Internal calculation method. Updates the various angle related properties.\r\n     *\r\n     * @private\r\n     */\r\n    checkArea ()\r\n    {\r\n        this.angle = Phaser.Math.RadToDeg(Phaser.Geom.Line.Angle(this.line));\r\n\r\n        let angleFull = this.angle;\r\n        let quadrant = 1;\r\n\r\n        if (angleFull < 0)\r\n        {\r\n            angleFull += 360;\r\n        }\r\n\r\n        if (angleFull >= 45 && angleFull < 135)\r\n        {\r\n            quadrant = 1;\r\n            this.direction = Phaser.DOWN;\r\n        }\r\n        else if (angleFull >= 135 && angleFull < 225)\r\n        {\r\n            quadrant = 2;\r\n            this.direction = Phaser.LEFT;\r\n        }\r\n        else if (angleFull >= 225 && angleFull < 315)\r\n        {\r\n            quadrant = 3;\r\n            this.direction = Phaser.UP;\r\n        }\r\n        else\r\n        {\r\n            quadrant = 0;\r\n            this.direction = Phaser.RIGHT;\r\n        }\r\n\r\n        this.angleFull = angleFull;\r\n        this.quadrant = quadrant;\r\n        this.octant = 45 * (Math.round(angleFull / 45));\r\n    }\r\n\r\n    /**\r\n     * Processes the movement event for this stick.\r\n     *\r\n     * @private\r\n     * @emits {StickMoveEvent}\r\n     * \r\n     * @param {Phaser.Input.Pointer} pointer - The Phaser Pointer that triggered the event.\r\n     */\r\n    moveStick (pointer)\r\n    {\r\n        const x = pointer.worldX;\r\n        const y = pointer.worldY;\r\n\r\n        if (!this.pointer || (!this.isDown && !this._tracking))\r\n        {\r\n            return;\r\n        }\r\n\r\n        const line = this.line;\r\n\r\n        if (this.motionLock === CONST.NONE)\r\n        {\r\n            line.x2 = x;\r\n            line.y2 = y;\r\n        }\r\n        else if (this.motionLock === CONST.HORIZONTAL)\r\n        {\r\n            line.x2 = x;\r\n        }\r\n        else if (this.motionLock === CONST.VERTICAL)\r\n        {\r\n            line.y2 = y;\r\n        }\r\n\r\n        this.checkArea();\r\n\r\n        const lineLength = Phaser.Geom.Line.Length(line);\r\n        const lineAngle = Phaser.Geom.Line.Angle(line);\r\n\r\n        if (!this.isDown && lineLength <= this.deadZone)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (this._tracking)\r\n        {\r\n            //  Was tracking, now in the zone so dispatch and follow\r\n            this.setDown();\r\n        }\r\n\r\n        if (lineLength < this.baseHitArea.radius)\r\n        {\r\n            if (this.motionLock === CONST.NONE)\r\n            {\r\n                this.stickHitArea.setPosition(x, y);\r\n            }\r\n            else if (this.motionLock === CONST.HORIZONTAL)\r\n            {\r\n                this.stickHitArea.x = x;\r\n            }\r\n            else if (this.motionLock === CONST.VERTICAL)\r\n            {\r\n                this.stickHitArea.y = y;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  Let it smoothly rotate around the base limit\r\n            const limitPoint = this.limitPoint;\r\n\r\n            Phaser.Geom.Circle.CircumferencePoint(this.baseHitArea, lineAngle, limitPoint);\r\n\r\n            if (this.motionLock === CONST.NONE)\r\n            {\r\n                this.stickHitArea.setPosition(limitPoint.x, limitPoint.y);\r\n            }\r\n            else if (this.motionLock === CONST.HORIZONTAL)\r\n            {\r\n                this.stickHitArea.x = limitPoint.x;\r\n            }\r\n            else if (this.motionLock === CONST.VERTICAL)\r\n            {\r\n                this.stickHitArea.y = limitPoint.y;\r\n            }\r\n        }\r\n\r\n        if (this.stickSprite)\r\n        {\r\n            this.stickSprite.setPosition(this.stickHitArea.x, this.stickHitArea.y);\r\n        }\r\n\r\n        this.emit('move', this, this.force, this.forceX, this.forceY);\r\n    }\r\n\r\n    /**\r\n     * The update callback. This is called automatically by the Virtual Joystick Plugin.\r\n     *\r\n     * @private\r\n     * @emits {StickUpdateEvent}\r\n     */\r\n    update ()\r\n    {\r\n        if (!this._tracking)\r\n        {\r\n            this.emit('update', this, this.force, this.forceX, this.forceY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visually aligns the joystick to the bottom left of the game view.\r\n     * The optional spacing parameter allows you to add a border between the edge of the game and the joystick.\r\n     *\r\n     * @param {number} [spacing=0] - The spacing to apply between the edge of the game and the joystick.\r\n     * \r\n     * @return {this} This joystick instance.\r\n     */\r\n    alignBottomLeft (spacing = 0)\r\n    {\r\n        if (this.baseSprite)\r\n        {\r\n            const w = (this.baseSprite.displayWidth / 2) + spacing;\r\n            const h = (this.baseSprite.displayHeight / 2) + spacing;\r\n    \r\n            this.posX = w;\r\n            this.posY = this.scene.scale.height - h;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Visually aligns the joystick to the bottom right of the game view.\r\n     * The optional spacing parameter allows you to add a border between the edge of the game and the joystick.\r\n     *\r\n     * @param {number} [spacing=0] - The spacing to apply between the edge of the game and the joystick.\r\n     * \r\n     * @return {this} This joystick instance.\r\n     */\r\n    alignBottomRight (spacing = 0)\r\n    {\r\n        if (this.baseSprite)\r\n        {\r\n            const w = (this.baseSprite.displayWidth / 2) + spacing;\r\n            const h = (this.baseSprite.displayHeight / 2) + spacing;\r\n\r\n            this.posX = this.scene.scale.width - w;\r\n            this.posY = this.scene.scale.height - h;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Destroys this Stick.\r\n     * \r\n     * Removes all associated event listeners and signals and calls destroy on the stick sprites.\r\n     */\r\n    destroy ()\r\n    {\r\n        const input = this.scene.sys.input;\r\n\r\n        input.off('pointerdown', this.checkDown, this);\r\n        input.off('pointerup', this.checkUp, this);\r\n        input.off('pointerupoutside', this.checkUp, this);\r\n        input.off('pointermove', this.moveStick, this);\r\n\r\n        this.removeAllListeners();\r\n\r\n        this.stickHitArea = null;\r\n        this.baseHitArea = null;\r\n        this.line = null;\r\n        this.limitPoint = null;\r\n        this.pointer = null;\r\n        this.scene = null;\r\n    }\r\n\r\n    /**\r\n     * A Stick can be motion locked. When locked it can only move along the specified axis.\r\n     * \r\n     * `motionLock = 0` will allow it to move freely.\r\n     * `motionLock = 1` will only allow it to move horizontally.\r\n     * `motionLock = 2` will only allow it to move vertically.\r\n     * \r\n     * @param {integer} [value=0] - The motion lock setting to use.\r\n     * \r\n     * @return {this} This joystick instance.\r\n     */\r\n    setMotionLock (value = 0)\r\n    {\r\n        this.motionLock = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * The dead zone is a distance in pixels within which the Stick isn't considered as down or moving.\r\n     * Only when it moves beyond this value does it start dispatching events.\r\n     * \r\n     * By default the deadZone is 15% of the given distance value. \r\n     * So if the distance is 100 pixels then the Stick won't be considered as active until it has moved at least 15 pixels from its base.\r\n     * \r\n     * This value is adjusted for scale.\r\n     * \r\n     * It should never be more than the `Stick.distance` value.\r\n     * \r\n     * @param {integer} [value=0] - The dead zone to use.\r\n     * \r\n     * @return {this} This joystick instance.\r\n     */\r\n    setDeadZone (value = 0)\r\n    {\r\n        this.deadZone = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the scale of the joystick.\r\n     *\r\n     * @param {number} value - The scale of the joystick.\r\n     * \r\n     * @return {this} This joystick instance.\r\n     */\r\n    setScale (value)\r\n    {\r\n        this.scale = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the alpha of the joystick.\r\n     *\r\n     * @param {number} value - The alpha of the joystick.\r\n     * \r\n     * @return {this} This joystick instance.\r\n     */\r\n    setAlpha (value)\r\n    {\r\n        this.alpha = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the visibility of the joystick.\r\n     * \r\n     * Note that this dpad will carry on processing and dispatching events even when not visible.\r\n     * If you wish to disable the dpad from processing events see `Stick.enabled`.\r\n     *\r\n     * @param {number} value - The visible state of the joystick.\r\n     * \r\n     * @return {this} This joystick instance.\r\n     */\r\n    setVisible (value)\r\n    {\r\n        this.visible = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Renders out a debug view of this DPad to the given Graphics and Text objects.\r\n     *\r\n     * It optionally renders the geometry involved in the dpad hit areas and calculation line.\r\n     * \r\n     * It also optionally renders text information relating to the current forces and angles.\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} [graphics] - Renders the geometry involved in the stick hit areas and calculation line to this Graphics object.\r\n     * @param {Phaser.GameObjects.Text} [text] - Renders text information relating to the current forces and angles to this Text object.\r\n     */\r\n    debug (graphics, text)\r\n    {\r\n        if (graphics)\r\n        {\r\n            graphics.clear();\r\n\r\n            graphics.lineStyle(2, 0xff0000);\r\n            graphics.strokeCircleShape(this.baseHitArea);\r\n\r\n            graphics.lineStyle(2, 0x00ff00);\r\n            graphics.strokeCircleShape(this.stickHitArea);\r\n\r\n            graphics.lineStyle(2, 0xffff00);\r\n            graphics.strokeLineShape(this.line);\r\n        }\r\n\r\n        if (text)\r\n        {\r\n            text.setText([\r\n                'Force: ' + this.force.toFixed(2),\r\n                'ForceX: ' + this.forceX.toFixed(2),\r\n                'ForceY: ' + this.forceY.toFixed(2),\r\n                '',\r\n                'Rotation: ' + this.rotation.toFixed(2),\r\n                'Angle: ' + this.angle.toFixed(2),\r\n                '',\r\n                'Distance: ' + this.distance,\r\n                'Quadrant: ' + this.quadrant,\r\n                'Octant: ' + this.octant\r\n            ]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The rotation of the stick from its base in radians.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get rotation ()\r\n    {\r\n        return Phaser.Geom.Line.Angle(this.line);\r\n    }\r\n\r\n    /**\r\n     * The current x value of the joystick.\r\n     * \r\n     * This is a value between -1 and 1 calculated based on the distance of the stick from its base.\r\n     * Where -1 is to the left of the base and +1 is to the right.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get x ()\r\n    {\r\n        const pi = Math.PI;\r\n        const tau = Phaser.Math.TAU;\r\n        const angle = Phaser.Geom.Line.Angle(this.line);\r\n\r\n        if (angle >= 0)\r\n        {\r\n            if (angle <= tau)\r\n            {\r\n                //   Bottom right (0 - 90)\r\n                return (tau - angle) / tau;\r\n            }\r\n            else\r\n            {\r\n                //   Bottom left (90 - 180)\r\n                return -1 + (((pi - angle) / pi) * 2);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (angle >= -tau)\r\n            {\r\n                //   Top right (0 to -90)\r\n                return (Math.abs(-tau - angle)) / tau;\r\n            }\r\n            else\r\n            {\r\n                //   Top left (-90 to -180)\r\n                return -1 + ((Math.abs(-pi - angle) / pi) * 2);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The current y value of the joystick.\r\n     * \r\n     * This is a value between -1 and 1 calculated based on the distance of the stick from its base.\r\n     * Where -1 is above the base and +1 is below the base.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get y ()\r\n    {\r\n        const tau = Phaser.Math.TAU;\r\n        const angle = Phaser.Geom.Line.Angle(this.line);\r\n\r\n        if (angle >= 0)\r\n        {\r\n            //  Down\r\n            return 1 - (Math.abs(tau - angle) / tau);\r\n        }\r\n        else\r\n        {\r\n            //  Up\r\n            return -1 + (Math.abs(-tau - angle) / tau);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The x coordinate the joystick is rendered at.\r\n     * Use this to change the position of the joystick on-screen.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get posX ()\r\n    {\r\n        return this.position.x;\r\n    }\r\n\r\n    /**\r\n     * The x coordinate the joystick is rendered at. Value should be given in pixel coordinates based on game dimensions.\r\n     * Use this to change the position of the joystick on-screen. Value can even be tweened to display or hide the joystick in interesting ways.\r\n     * \r\n     * @type {number}\r\n     */\r\n    set posX (x)\r\n    {\r\n        this.position.x = x;\r\n\r\n        if (this.baseSprite)\r\n        {\r\n            this.baseSprite.x = x;\r\n        }\r\n\r\n        if (this.stickSprite)\r\n        {\r\n            this.stickSprite.x = x;\r\n        }\r\n\r\n        this.baseHitArea.x = x;\r\n        this.stickHitArea.x = x;\r\n        this.line.x1 = x;\r\n        this.line.x2 = x;\r\n    }\r\n\r\n    /**\r\n     * The y coordinate the joystick is rendered at.\r\n     * Use this to change the position of the joystick on-screen.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get posY ()\r\n    {\r\n        return this.position.y;\r\n    }\r\n\r\n    /**\r\n     * The y coordinate the joystick is rendered at. Value should be given in pixel coordinates based on game dimensions.\r\n     * Use this to change the position of the joystick on-screen. Value can even be tweened to display or hide the joystick in interesting ways.\r\n     * \r\n     * @type {number}\r\n     */\r\n    set posY (y)\r\n    {\r\n        this.position.y = y;\r\n\r\n        if (this.baseSprite)\r\n        {\r\n            this.baseSprite.y = y;\r\n        }\r\n\r\n        if (this.stickSprite)\r\n        {\r\n            this.stickSprite.y = y;\r\n        }\r\n\r\n        this.baseHitArea.y = y;\r\n        this.stickHitArea.y = y;\r\n        this.line.y1 = y;\r\n        this.line.y2 = y;\r\n    }\r\n\r\n    /**\r\n     * The current force being applied to the joystick.\r\n     * \r\n     * This is a value between 0 and 1 calculated based on the distance of the stick from its base.\r\n     * It can be used to apply speed to physics objects, for example:\r\n     * \r\n     * `ArcadePhysics.velocityFromRotation(Stick.rotation, Stick.force * maxSpeed, Sprite.body.velocity)`\r\n     * \r\n     * @type {number}\r\n     */\r\n    get force ()\r\n    {\r\n        return Math.min(1, (Phaser.Geom.Line.Length(this.line) / this.distance * 2));\r\n    }\r\n\r\n    /**\r\n     * The current force being applied to the joystick on the horizontal axis.\r\n     * \r\n     * This is a value between 0 and 1 calculated based on the distance of the stick from its base.\r\n     *\r\n     * If you need to know which direction the Stick is facing (i.e. left or right) then see the `x` property value.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get forceX ()\r\n    {\r\n        return this.force * this.x;\r\n    }\r\n\r\n    /**\r\n     * The current force being applied to the joystick on the vertical axis.\r\n     * \r\n     * This is a value between 0 and 1 calculated based on the distance of the stick from its base.\r\n     *\r\n     * If you need to know which direction the Stick is facing (i.e. up or down) then see the `y` property value.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get forceY ()\r\n    {\r\n        return this.force * this.y;\r\n    }\r\n\r\n    /**\r\n     * The filterX value is the forceX value adjusted to be used as the mouse input uniform for a filter.\r\n     * \r\n     * This is a value between 0 and 1 where 0.5 is the center, i.e. the stick un-moved from its base.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get filterX ()\r\n    {\r\n        if (this.x === 0)\r\n        {\r\n            return 0.50;\r\n        }\r\n        else\r\n        {\r\n            const fx = Math.abs(this.forceX) / 2;\r\n\r\n            if (this.x < 0)\r\n            {\r\n                return (0.5 - fx).toFixed(2);\r\n            }\r\n            else\r\n            {\r\n                return (0.5 + fx).toFixed(2);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filterY value is the forceY value adjusted to be used as the mouse input uniform for a filter.\r\n     * \r\n     * This is a value between 0 and 1 where 0.5 is the center, i.e. the stick un-moved from its base.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get filterY ()\r\n    {\r\n        if (this.y === 0)\r\n        {\r\n            return 0.50;\r\n        }\r\n        else\r\n        {\r\n            const fy = Math.abs(this.forceY) / 2;\r\n\r\n            if (this.y < 0)\r\n            {\r\n                return 1 - (0.5 - fy).toFixed(2);\r\n            }\r\n            else\r\n            {\r\n                return 1 - (0.5 + fy).toFixed(2);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The alpha value of the Stick.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get alpha ()\r\n    {\r\n        return this.baseSprite.alpha;\r\n    }\r\n\r\n    /**\r\n     * The alpha value of the Stick.\r\n     * \r\n     * Adjusting this value changes the alpha property of both the base and stick sprites.\r\n     * Reading it reads the alpha value of the base sprite alone.\r\n     *\r\n     * If you need to give the base and stick sprites *different* alpha values then you can access them directly:\r\n     *\r\n     * `stick.baseSprite.alpha` and `stick.stickSprite.alpha`.\r\n     * \r\n     * Note that DPads only have a `baseSprite`.\r\n     * \r\n     * @type {number}\r\n     */\r\n    set alpha (value)\r\n    {\r\n        if (this.baseSprite)\r\n        {\r\n            this.baseSprite.setAlpha(value);\r\n        }\r\n\r\n        if (this.stickSprite)\r\n        {\r\n            this.stickSprite.setAlpha(value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The visible state of the Stick.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get visible ()\r\n    {\r\n        return (this.stickSprite) ? this.stickSprite.visible : false;\r\n    }\r\n\r\n    /**\r\n     * The visible state of the Stick.\r\n     * \r\n     * Adjusting this value changes the visible property of both the base and stick sprites.\r\n     * Reading it reads the visible value of the stick sprite alone.\r\n     *\r\n     * Note that this stick will carry on processing and dispatching events even when not visible.\r\n     * If you wish to disable the stick from processing events see `Stick.enabled`.\r\n     *\r\n     * If you need to give the base and stick sprites *different* visible values then you can access them directly:\r\n     *\r\n     * `stick.baseSprite.visible` and `stick.stickSprite.visible`.\r\n     * \r\n     * Note that DPads only have a `baseSprite`.\r\n     * \r\n     * @type {number}\r\n     */\r\n    set visible (value)\r\n    {\r\n        if (this.baseSprite)\r\n        {\r\n            this.baseSprite.setVisible(value);\r\n        }\r\n\r\n        if (this.stickSprite)\r\n        {\r\n            this.stickSprite.setVisible(value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The distance in pixels that the stick needs to move from the base before it's at 'full force'.\r\n     * \r\n     * This value is adjusted for scale.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get distance ()\r\n    {\r\n        return this._distance * this._scale;\r\n    }\r\n\r\n    /**\r\n     * The distance in pixels that the stick needs to move from the base before it's at 'full force'.\r\n     * \r\n     * This value is adjusted for scale.\r\n     * \r\n     * It should never be less than the `Stick.deadZone` value.\r\n     * \r\n     * @type {number}\r\n     */\r\n    set distance (value)\r\n    {\r\n        this._distance = value;\r\n    }\r\n\r\n    /**\r\n     * The dead zone is a distance in pixels within which the Stick isn't considered as down or moving.\r\n     * Only when it moves beyond this value does it start dispatching events.\r\n     * \r\n     * By default the deadZone is 10% of the given distance value. \r\n     * So if the distance is 100 pixels then the Stick won't be considered as active until it has moved at least 10 pixels from its base.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get deadZone ()\r\n    {\r\n        return this._deadZone * this._scale;\r\n    }\r\n\r\n    /**\r\n     * The dead zone is a distance in pixels within which the Stick isn't considered as down or moving.\r\n     * Only when it moves beyond this value does it start dispatching events.\r\n     * \r\n     * By default the deadZone is 10% of the given distance value. \r\n     * So if the distance is 100 pixels then the Stick won't be considered as active until it has moved at least 10 pixels from its base.\r\n     * \r\n     * This value is adjusted for scale.\r\n     * \r\n     * It should never be more than the `Stick.distance` value.\r\n     * \r\n     * @type {number}\r\n     */\r\n    set deadZone (value)\r\n    {\r\n        this._deadZone = value;\r\n    }\r\n\r\n    /**\r\n     * The scale of the Stick.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get scale ()\r\n    {\r\n        return this._scale;\r\n    }\r\n\r\n    /**\r\n     * The scale of the Stick. The scale is applied evenly to both the x and y axis of the Stick.\r\n     * You cannot specify a different scale per axis.\r\n     * \r\n     * Adjusting this value changes the scale of both the base and stick sprites and recalculates all of the hit areas.\r\n     *\r\n     * The base and stick sprites must have the same scale.\r\n     * \r\n     * @type {number}\r\n     */\r\n    set scale (value)\r\n    {\r\n        if (this.baseSprite)\r\n        {\r\n            this.baseSprite.setScale(value);\r\n        }\r\n\r\n        if (this.stickSprite)\r\n        {\r\n            this.stickSprite.setScale(value);\r\n        }\r\n\r\n        this.baseHitArea.setTo(this.position.x, this.position.y, (this.distance * value) / 2);\r\n\r\n        const stickWidth = (this.stickSprite) ? this.stickSprite.displayWidth : (this.distance * value) / 2;\r\n\r\n        this.stickHitArea.setTo(this.position.x, this.position.y, stickWidth);\r\n\r\n        this._scale = value;\r\n    }\r\n\r\n    /**\r\n     * A Stick that is set to `showOnTouch` will have `visible` set to false until the player presses on the screen.\r\n     * When this happens the Stick is centered on the x/y coordinate of the finger and can be immediately dragged for movement.\r\n     * \r\n     * @type {boolean}\r\n     */\r\n    get showOnTouch ()\r\n    {\r\n        return this._showOnTouch;\r\n    }\r\n\r\n    /**\r\n     * A Stick that is set to `showOnTouch` will have `visible` set to false until the player presses on the screen.\r\n     * When this happens the Stick is centered on the x/y coordinate of the finger and can be immediately dragged for movement.\r\n     * \r\n     * @type {boolean}\r\n     */\r\n    set showOnTouch (value)\r\n    {\r\n        this._showOnTouch = value;\r\n\r\n        if (this._showOnTouch && this.visible)\r\n        {\r\n            this.visible = false;\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = BaseStick;\r\n","/**\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2019 Photon Storm Ltd.\r\n* @license      {@link http://choosealicense.com/licenses/no-license/|No License}\r\n*/\r\n\r\nimport BaseStick from './BaseStick';\r\nimport CONST from './const';\r\n\r\n/**\r\n * A `DPad` is a virtual joystick. It belongs to the Virtual Joystick Plugin which is responsible for creating and updating it.\r\n *\r\n * Create a new stick by using the `VirtualJoystickPlugin.addDPad` method.\r\n *\r\n * While the Stick class creates an analogue joystick, the DPad one creates a digital joystick. The difference is that a digital joystick\r\n * is either \"on\" or \"off\" in any given direction. There is no pressure or degree of force in any direction, it's either moving or it isn't.\r\n * This is the same as the way in which NES style game pads work. The \"D\" stands for \"Direction\".\r\n *\r\n * Unlike the Stick class the DPad can use a different frame from the texture atlas for each of the 4 directions in which it can move.\r\n *\r\n * The DPad can either be on-screen all the time, positioned via the `posX` and `posY` setters. Or you can have it only appear when the\r\n * player touches the screen by setting `showOnTouch` to true.\r\n * \r\n * The DPad sprites are automatically added to the Scene at the point this DPad is created.\r\n */\r\nexport class DPad extends BaseStick\r\n{\r\n    /**\r\n     * @param {Phaser.Scene} scene - A reference to the Scene this stick was created in.\r\n     * @param {number} x - The x coordinate to draw the joystick at. The joystick is centered on this coordinate.\r\n     * @param {number} y - The y coordinate to draw the joystick at. The joystick is centered on this coordinate.\r\n     * @param {number} size - The size of the circular hit area for the DPad. If a falsey value it will use the size of the neutralFrame.\r\n     * @param {string} texture - The key of the texture atlas to be used to render this joystick.\r\n     * @param {string} [neutralFrame='neutral'] - The name of the frame within the texture atlas that contains the 'neutral' state of the dpad. Neutral is the state when the dpad isn't moved at all.\r\n     * @param {string} [upFrame='up'] - The name of the frame within the texture atlas that contains the 'up' state of the dpad.\r\n     * @param {string} [downFrame='down'] - The name of the frame within the texture atlas that contains the 'down' state of the dpad.\r\n     * @param {string} [leftFrame='left'] - The name of the frame within the texture atlas that contains the 'left' state of the dpad.\r\n     * @param {string} [rightFrame='right'] - The name of the frame within the texture atlas that contains the 'right' state of the dpad.\r\n     */\r\n    constructor (scene, x, y, size, texture, neutralFrame = 'neutral', upFrame = 'up', downFrame = 'down', leftFrame = 'left', rightFrame = 'right')\r\n    {\r\n        super(scene, x, y, size);\r\n\r\n        /**\r\n         * The name of the frame within the texture atlas that contains the 'neutral' state of the dpad. Neutral is the state when the dpad isn't moved at all.\r\n         * @type {string}\r\n         */\r\n        this.neutralFrame = neutralFrame;\r\n\r\n        /**\r\n         * The name of the frame within the texture atlas that contains the 'up' state of the dpad.\r\n         * @type {string}\r\n         */\r\n        this.upFrame = upFrame;\r\n\r\n        /**\r\n         * The name of the frame within the texture atlas that contains the 'down' state of the dpad.\r\n         * @type {string}\r\n         */\r\n        this.downFrame = downFrame;\r\n\r\n        /**\r\n         * The name of the frame within the texture atlas that contains the 'left' state of the dpad.\r\n         * @type {string}\r\n         */\r\n        this.leftFrame = leftFrame;\r\n\r\n        /**\r\n         * The name of the frame within the texture atlas that contains the 'right' state of the dpad.\r\n         * @type {string}\r\n         */\r\n        this.rightFrame = rightFrame;\r\n\r\n        /**\r\n         * @ignore\r\n         */\r\n        this.baseSprite = this.scene.add.sprite(x, y, texture, neutralFrame);\r\n\r\n        if (!size)\r\n        {\r\n            size = this.baseSprite.displayWidth;\r\n\r\n            /**\r\n             * @ignore\r\n             */\r\n            this.baseHitArea.radius = size / 2;\r\n\r\n            /**\r\n             * @ignore\r\n             */\r\n            this.stickHitArea.radius = size / 2;\r\n        }\r\n\r\n        /**\r\n         * The `repeatRate` allows you to set how often the DPad fires the direction events.\r\n         * \r\n         * At the default setting of zero the events will be sent only once and no further events\r\n         * will be sent until the DPad changes direction.\r\n         *\r\n         * By setting `repeatRate` to a value above zero you can control the time delay in milliseconds between each event.\r\n         *\r\n         * For example: `repeatRate = 100` would send the event once every 100ms for as long as\r\n         * the button is held down in the same direction.\r\n         *\r\n         * To disable a repeat rate set the value back to zero again.\r\n         * \r\n         * @type {integer}\r\n         */\r\n        this.repeatRate = 0;\r\n\r\n        /**\r\n         * Internal calculation var.\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._timeNext = 0;\r\n\r\n        /**\r\n         * Internal direction to event name mapping.\r\n         * @private\r\n         * @type {string[]}\r\n         */\r\n        this._directions = [ '', '', '', '', 'none', 'moveup', 'movedown', 'moveleft', 'moveright' ];\r\n\r\n        /**\r\n         * Internal tracking var.\r\n         * @type {integer}\r\n         * @private\r\n         */\r\n        this._lastDirection = 0;\r\n    }\r\n    \r\n    /**\r\n     * Processes the up event for this dpad.\r\n     *\r\n     * @private\r\n     * @override\r\n     * \r\n     * @param {Phaser.Input.Pointer} pointer - The Phaser Pointer that triggered the event.\r\n     */\r\n    checkUp (pointer)\r\n    {\r\n        if (pointer !== this.pointer)\r\n        {\r\n            return;\r\n        }\r\n\r\n        super.checkUp(pointer);\r\n\r\n        this.baseSprite.setFrame(this.neutralFrame);\r\n\r\n        this._lastDirection = 0;\r\n    }\r\n\r\n    /**\r\n     * Processes the movement event for this dpad.\r\n     *\r\n     * @private\r\n     * @override\r\n     * @fires {DPadMoveEvent}\r\n     * \r\n     * @param {Phaser.Input.Pointer} pointer - The Phaser Pointer that triggered the event.\r\n     */\r\n    moveStick (pointer)\r\n    {\r\n        if (pointer !== this.pointer)\r\n        {\r\n            return\r\n        }\r\n\r\n        const x = pointer.worldX;\r\n        const y = pointer.worldY;\r\n\r\n        if (!this.pointer || (!this.isDown && !this._tracking))\r\n        {\r\n            this.direction = Phaser.NONE;\r\n            this.baseSprite.setFrame(this.neutralFrame);\r\n\r\n            return;\r\n        }\r\n\r\n        const line = this.line;\r\n\r\n        line.x2 = x;\r\n        line.y2 = y;\r\n\r\n        this.checkArea();\r\n\r\n        const lineLength = Phaser.Geom.Line.Length(line);\r\n        const lineAngle = Phaser.Geom.Line.Angle(line);\r\n\r\n        if (!this.isDown && lineLength <= this.deadZone)\r\n        {\r\n            this.direction = Phaser.NONE;\r\n            this.baseSprite.setFrame(this.neutralFrame);\r\n\r\n            return;\r\n        }\r\n\r\n        if (this._tracking)\r\n        {\r\n            //  Was tracking, now in the zone so dispatch and follow\r\n            this.setDown();\r\n        }\r\n\r\n        const motionLock = this.motionLock;\r\n        const stickHitArea = this.stickHitArea;\r\n        const quadrant = this.quadrant;\r\n\r\n        if (lineLength < this.baseHitArea.radius)\r\n        {\r\n            if (motionLock === CONST.NONE)\r\n            {\r\n                stickHitArea.setPosition(x, y);\r\n            }\r\n            else if (motionLock === CONST.HORIZONTAL)\r\n            {\r\n                stickHitArea.x = x;\r\n            }\r\n            else if (motionLock === CONST.VERTICAL)\r\n            {\r\n                stickHitArea.y = y;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  Let it smoothly rotate around the base limit\r\n            const limitPoint = this.limitPoint;\r\n\r\n            Phaser.Geom.Circle.CircumferencePoint(this.baseHitArea, lineAngle, limitPoint);\r\n\r\n            if (motionLock === CONST.NONE)\r\n            {\r\n                stickHitArea.setPosition(limitPoint.x, limitPoint.y);\r\n            }\r\n            else if (motionLock === CONST.HORIZONTAL)\r\n            {\r\n                stickHitArea.x = limitPoint.x;\r\n            }\r\n            else if (motionLock === CONST.VERTICAL)\r\n            {\r\n                stickHitArea.y = limitPoint.y;\r\n            }\r\n        }\r\n\r\n        if (quadrant === 1)\r\n        {\r\n            this.baseSprite.setFrame(this.downFrame);\r\n        }\r\n        else if (quadrant === 2)\r\n        {\r\n            this.baseSprite.setFrame(this.leftFrame);\r\n        }\r\n        else if (quadrant === 3)\r\n        {\r\n            this.baseSprite.setFrame(this.upFrame);\r\n        }\r\n        else\r\n        {\r\n            this.baseSprite.setFrame(this.rightFrame);\r\n        }\r\n\r\n        this.emit('move', this, this.x, this.y);\r\n    }\r\n\r\n    /**\r\n     * The update callback. This is called automatically by the Virtual Joystick Plugin.\r\n     *\r\n     * @private\r\n     * @override\r\n     * @fires {DPadUpdateEvent}\r\n     * @fires {DPadLeftEvent}\r\n     * @fires {DPadRightEvent}\r\n     * @fires {DPadUpEvent}\r\n     * @fires {DPadDownEvent}\r\n     * \r\n     * @param {integer} time - The current time.\r\n     */\r\n    update (time)\r\n    {\r\n        if (!this._tracking)\r\n        {\r\n            this.emit('update', this, this.x, this.y);\r\n\r\n            if (this.direction !== Phaser.NONE && this.isDown)\r\n            {\r\n                if ((this.direction !== this._lastDirection) || (this.repeatRate > 0 && time >= this._timeNext))\r\n                {\r\n                    this.emit(this._directions[this.direction], this);\r\n    \r\n                    this._timeNext = time + this.repeatRate;\r\n\r\n                    this._lastDirection = this.direction;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The `repeatRate` allows you to set how often the DPad fires the direction events.\r\n     * \r\n     * At the default setting of zero the events will be sent only once and no further events\r\n     * will be sent until the DPad changes direction.\r\n     *\r\n     * By setting `repeatRate` to a value above zero you can control the time delay in milliseconds between each event.\r\n     *\r\n     * For example: `repeatRate = 100` would send the event once every 100ms for as long as\r\n     * the button is held down in the same direction.\r\n     *\r\n     * To disable a repeat rate set the value back to zero again.\r\n     *\r\n     * @param {integer} [rate=0] - The repeat rate.\r\n     * \r\n     * @return {DPad} This joystick instance.\r\n     */\r\n    setRepeatRate (rate = 0)\r\n    {\r\n        this.repeatRate = rate;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Destroys this dpad.\r\n     * \r\n     * Removes all associated listeners and events and calls destroy on the dpad sprite.\r\n     * \r\n     * @override\r\n     */\r\n    destroy ()\r\n    {\r\n        super.destroy();\r\n\r\n        this.baseSprite.destroy();\r\n\r\n        this.baseSprite = null;\r\n    }\r\n\r\n    /**\r\n     * Renders out a debug view of this DPad to the given Graphics and Text objects.\r\n     *\r\n     * It optionally renders the geometry involved in the dpad hit areas and calculation line.\r\n     * \r\n     * It also optionally renders text information relating to the current forces and angles.\r\n     *\r\n     * @override\r\n     * @param {Phaser.GameObjects.Graphics} [graphics] - Renders the geometry involved in the stick hit areas and calculation line to this Graphics object.\r\n     * @param {Phaser.GameObjects.Text} [text] - Renders text information relating to the current forces and angles to this Text object.\r\n     */\r\n    debug (graphics, text)\r\n    {\r\n        super.debug(graphics);\r\n\r\n        if (text)\r\n        {\r\n            text.setText([\r\n                'X: ' + this.x,\r\n                'Y: ' + this.y,\r\n                'Direction: ' + this._directions[this.direction].substr(4),\r\n                '',\r\n                'Distance: ' + this.distance,\r\n                'Quadrant: ' + this.quadrant,\r\n                'Octant: ' + this.octant\r\n            ]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The current x value of the dpad.\r\n     *\r\n     * If the dpad is being held to the left it will return -1. If to the right it will return 1.\r\n     * If either not held at all, or not left or right, it will return 0.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get x ()\r\n    {\r\n        if (this.direction === Phaser.LEFT)\r\n        {\r\n            return -1;\r\n        }\r\n        else if (this.direction === Phaser.RIGHT)\r\n        {\r\n            return 1;\r\n        }\r\n        else\r\n        {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The current y value of the joystick.\r\n     * \r\n     * If the dpad is being held up it will return -1. If down it will return 1.\r\n     * If either not held at all, or not up or down, it will return 0.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get y ()\r\n    {\r\n        if (this.direction === Phaser.UP)\r\n        {\r\n            return -1;\r\n        }\r\n        else if (this.direction === Phaser.DOWN)\r\n        {\r\n            return 1;\r\n        }\r\n        else\r\n        {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The current force being applied to the joystick.\r\n     * \r\n     * For a DPad it is either 0 or 1.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get force ()\r\n    {\r\n        return (this.isDown) ? 1 : 0;\r\n    }\r\n\r\n    /**\r\n     * The current force being applied to the joystick on the horizontal axis.\r\n     * \r\n     * For a DPad it is either -1, 0 or 1.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get forceX ()\r\n    {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * The current force being applied to the joystick on the vertical axis.\r\n     * \r\n     * For a DPad it is either -1, 0 or 1.\r\n     * \r\n     * @type {number}\r\n     */\r\n    get forceY ()\r\n    {\r\n        return this.y;\r\n    }\r\n}\r\n\r\n/**\r\n * The Move event is dispatched whenever the joystick is moved as a result of a device Touch movement event.\r\n * \r\n * This event is only dispatched when a touch move event is received, even if the stick is held in a specific direction.\r\n * \r\n * If you wish to constantly check the position of the joystick then you should use the Update event instead.\r\n * \r\n * Listen to this event from a stick instance:\r\n * \r\n * ```javascript\r\n * const stick = this.pad.addDPad(...);\r\n * stick.on('move', handler);\r\n * ```\r\n * \r\n * @typedef {Object} DPadMoveEvent\r\n * @property {DPad} dpad - The DPad that fired the event.\r\n * @property {integer} forceX - The current force being applied to the joystick on the horizontal axis.\r\n * @property {integer} forceY - The current force being applied to the joystick on the vertical axis.\r\n */\r\n\r\n /**\r\n * The Update event is dispatched constantly for as long as the joystick is in a down state.\r\n * \r\n * This is a high frequency event so be careful what is bound to it. If there are computationally cheaper ways of \r\n * reacting to this joysticks movement then you should explore them.\r\n * \r\n * Listen to this event from a stick instance:\r\n * \r\n * ```javascript\r\n * const stick = this.pad.addDPad(...);\r\n * stick.on('update', handler);\r\n * ```\r\n * \r\n * @typedef {Object} DPadUpdateEvent\r\n * @property {DPad} dpad - The DPad that fired the event.\r\n * @property {integer} forceX - The current force being applied to the joystick on the horizontal axis.\r\n * @property {integer} forceY - The current force being applied to the joystick on the vertical axis.\r\n */\r\n\r\n/**\r\n * This event is dispatched whenever the DPad is pressed left.\r\n * \r\n * See the `repeatRate` property to control the frequency of the event.\r\n * \r\n * If you wish to constantly check the position of the joystick then you should use the Update event instead.\r\n * \r\n * Listen to this event from a stick instance:\r\n * \r\n * ```javascript\r\n * const stick = this.pad.addDPad(...);\r\n * stick.on('moveleft', handler);\r\n * ```\r\n * \r\n * @typedef {Object} DPadLeftEvent\r\n * @property {DPad} dpad - The dpad that fired the event.\r\n */\r\n\r\n /**\r\n * This event is dispatched whenever the DPad is pressed right.\r\n * \r\n * See the `repeatRate` property to control the frequency of the event.\r\n * \r\n * If you wish to constantly check the position of the joystick then you should use the Update event instead.\r\n * \r\n * Listen to this event from a stick instance:\r\n * \r\n * ```javascript\r\n * const stick = this.pad.addDPad(...);\r\n * stick.on('moveright', handler);\r\n * ```\r\n * \r\n * @typedef {Object} DPadRightEvent\r\n * @property {DPad} dpad - The dpad that fired the event.\r\n */\r\n\r\n/**\r\n * This event is dispatched whenever the DPad is pressed down.\r\n * \r\n * See the `repeatRate` property to control the frequency of the event.\r\n * \r\n * If you wish to constantly check the position of the joystick then you should use the Update event instead.\r\n * \r\n * Listen to this event from a stick instance:\r\n * \r\n * ```javascript\r\n * const stick = this.pad.addDPad(...);\r\n * stick.on('movedown', handler);\r\n * ```\r\n * \r\n * @typedef {Object} DPadDownEvent\r\n * @property {DPad} dpad - The dpad that fired the event.\r\n */\r\n\r\n/**\r\n * This event is dispatched whenever the DPad is pressed up.\r\n * \r\n * See the `repeatRate` property to control the frequency of the event.\r\n * \r\n * If you wish to constantly check the position of the joystick then you should use the Update event instead.\r\n * \r\n * Listen to this event from a stick instance:\r\n * \r\n * ```javascript\r\n * const stick = this.pad.addDPad(...);\r\n * stick.on('moveup', handler);\r\n * ```\r\n * \r\n * @typedef {Object} DPadUpEvent\r\n * @property {DPad} dpad - The dpad that fired the event.\r\n */\r\n\r\nmodule.exports = DPad;\r\n","/**\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2019 Photon Storm Ltd.\r\n* @license      {@link http://choosealicense.com/licenses/no-license/|No License}\r\n*/\r\n\r\nimport BaseStick from './BaseStick';\r\n\r\n/**\r\n * A `Stick` is a virtual joystick. It belongs to the Virtual Joystick Plugin which is responsible for creating and updating it.\r\n *\r\n * Create a new stick by using the `VirtualJoystickPlugin.addStick` method.\r\n * \r\n * It consists of two Sprites: one representing the 'base' of the joystick and the other the 'stick' itself, which is the part\r\n * that the player grabs hold of and interacts with. As the stick is moved you can read back the force being applied, either globally\r\n * or on a per axis basis.\r\n *\r\n * The Stick can either be on-screen all the time, positioned via the `posX` and `posY` setters. Or you can have it only appear when the\r\n * player touches the screen by setting `showOnTouch` to true.\r\n *\r\n * The Stick sprites are automatically added to the Scene at the point this Stick is created.\r\n * \r\n * Stick force values are analogue, that is they are values between 0 and 1 that vary depending on how the stick\r\n * is being moved. This allows players to have fine-grained control over your game. If you require just an 'on / off' response you may\r\n * wish to use the DPad class instead.\r\n */\r\nexport class Stick extends BaseStick\r\n{\r\n    /**\r\n     * @param {Phaser.Scene} scene - A reference to the Scene this stick was created in.\r\n     * @param {number} x - The x coordinate to draw the joystick at. The joystick is centered on this coordinate.\r\n     * @param {number} y - The y coordinate to draw the joystick at. The joystick is centered on this coordinate.\r\n     * @param {number} distance - The distance threshold between the stick and the base. This is how far the stick can be pushed in any direction.\r\n     * @param {string} texture - The key of the texture atlas to be used to render this joystick.\r\n     * @param {string} [baseFrame='base'] - The name of the frame within the joystick texture atlas that contains the 'base' image.\r\n     * @param {string} [stickFrame='stick'] - The name of the frame within the joystick texture atlas that contains the 'stick' image.\r\n     */\r\n    constructor (scene, x, y, distance, texture, baseFrame = 'base', stickFrame = 'stick')\r\n    {\r\n        super(scene, x, y, distance);\r\n\r\n        /**\r\n         * The name of the frame within the joystick texture atlas that contains the 'base' image.\r\n         * @type {string} baseFrame\r\n         */\r\n        this.baseFrame = baseFrame;\r\n\r\n        /**\r\n         * The name of the frame within the joystick texture atlas that contains the 'stick' image.\r\n         * @type {string} stickFrame\r\n         */\r\n        this.stickFrame = stickFrame;\r\n\r\n        /**\r\n         * The Sprite that is used to display the base of the joystick.\r\n         * @type {Phaser.GameObjects.Sprite}\r\n         */\r\n        this.baseSprite = this.scene.add.sprite(x, y, texture, baseFrame);\r\n\r\n        /**\r\n         * The Sprite that is used to display the stick or handle of the joystick.\r\n         * @type {Phaser.GameObjects.Sprite}\r\n         */\r\n        this.stickSprite = this.scene.add.sprite(x, y, texture, stickFrame);\r\n\r\n        this.stickHitArea.radius = this.stickSprite.width / 2;\r\n    }\r\n\r\n    /**\r\n     * Destroys this Stick.\r\n     * \r\n     * Removes all associated listeners and events and calls destroy on the stick sprites.\r\n     */\r\n    destroy ()\r\n    {\r\n        super.destroy();\r\n\r\n        this.stickSprite.destroy();\r\n        this.baseSprite.destroy();\r\n\r\n        this.stickSprite = null;\r\n        this.baseSprite = null;\r\n    }\r\n}\r\n\r\n/**\r\n * The Down event is dispatched as soon as the joystick is touched, or clicked when under mouse emulation.\r\n * If it has a `deadZone` set then it's not dispatched until it has moved beyond the limits of the deadZone.\r\n * \r\n * Listen to this event from a stick instance:\r\n * \r\n * ```javascript\r\n * const stick = this.pad.addStick(...);\r\n * stick.on('down', handler);\r\n * ```\r\n * \r\n * @typedef {Object} DownEvent\r\n * @property {Stick|HiddenStick|DPad} stick - The stick that fired the event.\r\n * @property {Phaser.Input.Pointer} pointer - The Phaser Pointer responsible for causing the event.\r\n */\r\n\r\n/**\r\n * The Up event is dispatched as soon as the joystick is released, having previously been in an `isDown` state.\r\n * \r\n * Listen to this event from a stick instance:\r\n * \r\n * ```javascript\r\n * const stick = this.pad.addStick(...);\r\n * stick.on('up', handler);\r\n * ```\r\n * \r\n * @typedef {Object} UpEvent\r\n * @property {Stick|HiddenStick|DPad} stick - The stick that fired the event.\r\n * @property {Phaser.Input.Pointer} pointer - The Phaser Pointer responsible for causing the event.\r\n */\r\n\r\n/**\r\n * The Move event is dispatched whenever the joystick is moved as a result of a device Touch movement event.\r\n * \r\n * This event is only dispatched when a touch move event is received, even if the stick is held in a specific direction.\r\n * \r\n * If you wish to constantly check the position of the joystick then you should use the Update event instead.\r\n * \r\n * Listen to this event from a stick instance:\r\n * \r\n * ```javascript\r\n * const stick = this.pad.addStick(...);\r\n * stick.on('move', handler);\r\n * ```\r\n * \r\n * @typedef {Object} StickMoveEvent\r\n * @property {Stick|HiddenStick} stick - The stick that fired the event.\r\n * @property {number} force - The current force being applied to the joystick.\r\n * @property {number} forceX - The current force being applied to the joystick on the horizontal axis.\r\n * @property {number} forceY - The current force being applied to the joystick on the vertical axis.\r\n */\r\n\r\n/**\r\n * The Update event is dispatched constantly for as long as the joystick is in a down state.\r\n * \r\n * This is a high frequency event so be careful what is bound to it. If there are computationally cheaper ways of \r\n * reacting to this joysticks movement then you should explore them.\r\n * \r\n * Listen to this event from a stick instance:\r\n * \r\n * ```javascript\r\n * const stick = this.pad.addStick(...);\r\n * stick.on('update', handler);\r\n * ```\r\n * \r\n * @typedef {Object} StickUpdateEvent\r\n * @property {Stick|HiddenStick} stick - The stick that fired the event.\r\n * @property {number} force - The current force being applied to the joystick.\r\n * @property {number} forceX - The current force being applied to the joystick on the horizontal axis.\r\n * @property {number} forceY - The current force being applied to the joystick on the vertical axis.\r\n */\r\n\r\nmodule.exports = Stick;\r\n","/**\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2019 Photon Storm Ltd.\r\n* @license      {@link http://choosealicense.com/licenses/no-license/|No License}\r\n*/\r\n\r\nimport BaseStick from './BaseStick';\r\n\r\n/**\r\n * A `HiddenStick` is a virtual joystick with no on-screen visuals.\r\n * It belongs to the Virtual Joystick Plugin which is responsible for creating and updating it.\r\n *\r\n * Create a new stick by using the `VirtualJoystickPlugin.addHiddenStick` method.\r\n * \r\n * The Stick is active the moment you touch the screen, no matter where you touch it.\r\n * As such, changing the position, alpha, visible or scale of this stick has no impact.\r\n * \r\n * Stick force values are analogue, that is they are values between 0 and 1 that vary depending on how the stick\r\n * is being moved. This allows players to have fine-grained control over your game. If you require just an 'on / off' response you may\r\n * wish to use the DPad class instead.\r\n */\r\nexport class HiddenStick extends BaseStick\r\n{\r\n    /**\r\n     * @param {Phaser.Scene} scene - A reference to the Scene this stick was created in.\r\n     * @param {number} distance - The distance threshold between the stick and the base. This is how far the stick can be pushed in any direction.\r\n     */\r\n    constructor (scene, distance)\r\n    {\r\n        super(scene, 0, 0, distance);\r\n\r\n        this._showOnTouch = true;\r\n    }\r\n\r\n    /**\r\n     * Setting this property has no effect for a HiddenStick.\r\n     * \r\n     * @type {boolean}\r\n     */\r\n    set showOnTouch (value)\r\n    {\r\n        //  NOOP\r\n    }\r\n}\r\n\r\nmodule.exports = HiddenStick;\r\n","/**\r\n* @author       Richard Davey <rich@photonstorm.com>\r\n* @copyright    2019 Photon Storm Ltd.\r\n* @license      {@link http://choosealicense.com/licenses/no-license/|No License}\r\n*/\r\n\r\nimport CONST from './const';\r\nimport Button from './Button';\r\nimport DPad from './DPad';\r\nimport Stick from './Stick';\r\nimport HiddenStick from './HiddenStick';\r\n\r\n/**\r\n * The Virtual Joystick plugin.\r\n * \r\n * This plugin is responsible for all joysticks and buttons created within a Scene.\r\n *\r\n * Add it via the Scene Plugin Loader:\r\n * \r\n * `this.load.scenePlugin('VirtualJoystickPlugin', 'src/VirtualJoystickPlugin.js', 'VirtualJoystickPlugin', 'pad');`\r\n * \r\n * This will add a new property called `pad` to every Scene.\r\n *\r\n * Once created you can then add new joysticks and buttons using `this.pad.addStick` and `this.pad.addButton` respectively.\r\n * \r\n * This plugin can create multiple sticks and buttons and will handle processing and updating them all.\r\n */\r\nexport class VirtualJoystick\r\n{\r\n    /**\r\n     * @param {Phaser.Scene} scene - A reference to the Scene that has installed this plugin.\r\n     * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the Plugin Manager.\r\n     */\r\n    constructor (scene, pluginManager)\r\n    {\r\n        /**\r\n         * A handy reference to the Plugin Manager that is responsible for this plugin.\r\n         * Can be used as a route to gain access to game systems and  events.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#pluginManager\r\n         * @type {Phaser.Plugins.PluginManager}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.pluginManager = pluginManager;\r\n\r\n        /**\r\n         * A reference to the Game instance this plugin is running under.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#game\r\n         * @type {Phaser.Game}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.game = pluginManager.game;\r\n\r\n        /**\r\n         * A reference to the Scene that has installed this plugin.\r\n         * Only set if it's a Scene Plugin, otherwise `null`.\r\n         * This property is only set when the plugin is instantiated and added to the Scene, not before.\r\n         * You cannot use it during the `init` method, but you can during the `boot` method.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#scene\r\n         * @type {?Phaser.Scene}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Scene Systems of the Scene that has installed this plugin.\r\n         * Only set if it's a Scene Plugin, otherwise `null`.\r\n         * This property is only set when the plugin is instantiated and added to the Scene, not before.\r\n         * You cannot use it during the `init` method, but you can during the `boot` method.\r\n         *\r\n         * @name Phaser.Plugins.BasePlugin#systems\r\n         * @type {?Phaser.Scenes.Systems}\r\n         * @protected\r\n         * @since 3.8.0\r\n         */\r\n        this.systems = scene.sys;\r\n\r\n        /**\r\n         * The Sticks that this plugin is responsible for.\r\n         * @type {Set}\r\n         */\r\n        this.sticks = null;\r\n\r\n        /**\r\n         * The Buttons that this plugin is responsible for.\r\n         * @type {Set}\r\n         */\r\n        this.buttons = null;\r\n\r\n        /**\r\n         * Internal var to track the Input pointer total.\r\n         * @type {integer}\r\n         * @private\r\n         */\r\n        this._pointerTotal = 0;\r\n\r\n        scene.sys.events.once('boot', this.boot, this);\r\n    }\r\n\r\n    /**\r\n     * The boot method.\r\n     * \r\n     * @private\r\n     */\r\n    boot ()\r\n    {\r\n        this.systems.events.once('destroy', this.destroy, this);\r\n\r\n        //  Because they may load the plugin via the Loader\r\n        if (this.systems.settings.active)\r\n        {\r\n            this.start();\r\n        }\r\n        else\r\n        {\r\n            this.systems.events.on('start', this.start, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The start method.\r\n     * \r\n     * @private\r\n     */\r\n    start ()\r\n    {\r\n        this.sticks = new Set();\r\n        this.buttons = new Set();\r\n\r\n        this.systems.events.on('update', this.update, this);\r\n        this.systems.events.once('shutdown', this.shutdown, this);\r\n    }\r\n\r\n    /**\r\n     * Creates a new `Stick` object.\r\n     *\r\n     * `const stick = this.pad.addStick(x, y, distance, 'texture');`\r\n     * \r\n     * It consists of two Sprites: one representing the 'base' of the joystick and the other the 'stick' itself, which is the part\r\n     * that the player grabs hold of and interacts with. As the stick is moved you can read back the force being applied, either globally\r\n     * or on a per axis basis.\r\n     *\r\n     * The Stick can either be on-screen all the time, positioned via the `posX` and `posY` setters. Or you can have it only appear when the\r\n     * player touches the screen by setting `showOnTouch` to true.\r\n     *\r\n     * The Stick sprites are automatically added to the Scene at the point this Stick is created.\r\n     * \r\n     * Stick force values are analogue, that is they are values between 0 and 1 that vary depending on how the stick\r\n     * is being moved. This allows players to have fine-grained control over your game. If you require just an 'on / off' response you may\r\n     * wish to use the DPad class instead.\r\n     *\r\n     * @param {number} x - The x coordinate to draw the joystick at. The joystick is centered on this coordinate.\r\n     * @param {number} y - The y coordinate to draw the joystick at. The joystick is centered on this coordinate.\r\n     * @param {number} distance - The distance threshold between the stick and the base. This is how far the stick can be pushed in any direction.\r\n     * @param {string} texture - The key of the texture atlas to be used to render this joystick.\r\n     * @param {string} [baseFrame='base'] - The name of the base frame within the joystick texture atlas.\r\n     * @param {string} [stickFrame='stick'] - The name of the stick frame within the joystick texture atlas.\r\n     * \r\n     * @return {Stick} The Stick object.\r\n     */\r\n    addStick (x, y, distance, texture, baseFrame = 'base', stickFrame = 'stick')\r\n    {\r\n        const stick = new Stick(this.scene, x, y, distance, texture, baseFrame, stickFrame);\r\n\r\n        this.sticks.add(stick);\r\n\r\n        this._pointerTotal++;\r\n\r\n        if (this._pointerTotal > 2)\r\n        {\r\n            this.scene.sys.input.addPointer();\r\n        }\r\n\r\n        return stick;\r\n    }\r\n\r\n    /**\r\n     * Creates a new `HiddenStick` object.\r\n     *\r\n     * `const stick = this.pad.addHiddenStick(distance);`\r\n     * \r\n     * A `HiddenStick` is a virtual joystick with no on-screen visuals.\r\n     * It belongs to the Virtual Joystick Plugin which is responsible for creating and updating it.\r\n     * \r\n     * The Stick is active the moment you touch the screen, no matter where you touch it.\r\n     * As such, changing the position, alpha, visible or scale of this stick has no impact.\r\n     * \r\n     * Stick force values are analogue, that is they are values between 0 and 1 that vary depending on how the stick\r\n     * is being moved. This allows players to have fine-grained control over your game. If you require just an 'on / off' response you may\r\n     * wish to use the DPad class instead.\r\n     *\r\n     * @param {number} distance - The distance threshold between the stick and the base. This is how far the stick can be pushed in any direction.\r\n     * \r\n     * @return {HiddenStick} The HiddenStick object.\r\n     */\r\n    addHiddenStick (distance)\r\n    {\r\n        const stick = new HiddenStick(this.scene, distance);\r\n\r\n        this.sticks.add(stick);\r\n\r\n        this._pointerTotal++;\r\n\r\n        if (this._pointerTotal > 2)\r\n        {\r\n            this.scene.sys.input.addPointer();\r\n        }\r\n\r\n        return stick;\r\n    }\r\n\r\n    /**\r\n     * Creates a new `DPad` object.\r\n     *\r\n     * `const dpad = this.pad.addDPad(x, y, size, 'texture');`\r\n     *\r\n     * While the Stick class creates an analogue joystick, the DPad one creates a digital joystick. The difference is that a digital joystick\r\n     * is either \"on\" or \"off\" in any given direction. There is no pressure or degree of force in any direction, it's either moving or it isn't.\r\n     * This is the same as the way in which NES style game pads work. The \"D\" stands for \"Direction\".\r\n     *\r\n     * Unlike the Stick class the DPad can use a different frame from the texture atlas for each of the 4 directions in which it can move.\r\n     *\r\n     * The DPad can either be on-screen all the time, positioned via the `posX` and `posY` setters. Or you can have it only appear when the\r\n     * player touches the screen by setting `showOnTouch` to true.\r\n     *\r\n     * The DPad sprites are automatically added to the Scene at the point this Stick is created.\r\n     *\r\n     * @param {number} x - The x coordinate to draw the joystick at. The joystick is centered on this coordinate.\r\n     * @param {number} y - The y coordinate to draw the joystick at. The joystick is centered on this coordinate.\r\n     * @param {number} size - The size of the circular hit area for the DPad. If a falsey value it will use the size of the neutralFrame.\r\n     * @param {string} texture - The key of the texture atlas to be used to render this joystick.\r\n     * @param {string} [neutralFrame=neutral] - The name of the frame within the texture atlas that contains the 'neutral' state of the dpad. Neutral is the state when the dpad isn't moved at all.\r\n     * @param {string} [upFrame=up] - The name of the frame within the texture atlas that contains the 'up' state of the dpad.\r\n     * @param {string} [downFrame=down] - The name of the frame within the texture atlas that contains the 'down' state of the dpad.\r\n     * @param {string} [leftFrame=left] - The name of the frame within the texture atlas that contains the 'left' state of the dpad.\r\n     * @param {string} [rightFrame=right] - The name of the frame within the texture atlas that contains the 'right' state of the dpad.\r\n     * \r\n     * @return {DPad} The DPad object.\r\n     */\r\n    addDPad (x, y, size, texture, neutralFrame = 'neutral', upFrame = 'up', downFrame = 'down', leftFrame = 'left', rightFrame = 'right')\r\n    {\r\n        const stick = new DPad(this.scene, x, y, size, texture, neutralFrame, upFrame, downFrame, leftFrame, rightFrame);\r\n\r\n        this.sticks.add(stick);\r\n\r\n        this._pointerTotal++;\r\n\r\n        if (this._pointerTotal > 2)\r\n        {\r\n            this.scene.sys.input.addPointer();\r\n        }\r\n\r\n        return stick;\r\n    }\r\n\r\n    /**\r\n     * Removes the given Stick or DPad object from this plugin and then calls `destroy` on it.\r\n     *\r\n     * @param {Stick|HiddenStick|DPad} stick - The Stick or DPad object to be destroyed and removed.\r\n     */\r\n    removeStick (stick)\r\n    {\r\n        this.sticks.remove(stick);\r\n\r\n        stick.destroy();\r\n\r\n        this._pointerTotal--;\r\n    }\r\n\r\n    /**\r\n     * Creates a new `Button` object - a virtual button.\r\n     *\r\n     * `const button = this.pad.addButton(x, y, 'texture', 'button-up', 'button-down');`\r\n     * \r\n     * It consists of one sprite with two frames. One frame depicts the button as it's held down, the other when up.\r\n     *\r\n     * The Button sprites are automatically added to the Scene at the point this Button is created.\r\n     *\r\n     * The Button is digital, i.e. it is either 'on or off'. It doesn't have a pressure or force associated with it.\r\n     *\r\n     * @param {number} x - The x coordinate to draw the button at. The button is centered on this coordinate.\r\n     * @param {number} y - The y coordinate to draw the button at. The button is centered on this coordinate.\r\n     * @param {string} texture - The key of the texture atlas to be used to render this button.\r\n     * @param {string} upFrame - The name of the frame within the button texture atlas to be used when the button is in an 'up' state.\r\n     * @param {string} downFrame - The name of the frame within the button texture atlas to be used when the button is in a 'down' state.\r\n     * @param {integer} shape - The shape of the buttons hit area. Either `VirtualJoystick.CIRC_BUTTON` or `VirtualJoystick.RECT_BUTTON`.\r\n     * \r\n     * @return {Button} The Button object.\r\n     */\r\n    addButton (x, y, texture, upFrame, downFrame, shape = CONST.CIRC_BUTTON)\r\n    {\r\n        const button = new Button(this.scene, shape, x, y, texture, upFrame, downFrame);\r\n\r\n        this.buttons.add(button);\r\n\r\n        this._pointerTotal++;\r\n\r\n        if (this._pointerTotal > 2)\r\n        {\r\n            this.scene.sys.input.addPointer();\r\n        }\r\n\r\n        return button;\r\n    }\r\n\r\n    /**\r\n     * Removes the given Button object from this plugin and then calls `Button.destroy` on it.\r\n     *\r\n     * @param {Button|Button[]} button - The Button object, or an array of Buttons, to be destroyed and removed.\r\n     */\r\n    removeButton (button)\r\n    {\r\n        if (Array.isArray(button))\r\n        {\r\n            for (const b of button)\r\n            {\r\n                this.buttons.remove(b);\r\n\r\n                b.destroy();\r\n        \r\n                this._pointerTotal--;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.buttons.remove(button);\r\n\r\n            button.destroy();\r\n    \r\n            this._pointerTotal--;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called automatically by the Phaser Plugin Manager.\r\n     * \r\n     * Updates all Stick and Button objects.\r\n     * \r\n     * @param {integer} time - The current game timestep.\r\n     */\r\n    update (time)\r\n    {\r\n        for (const stick of this.sticks)\r\n        {\r\n            stick.update(time);\r\n        }\r\n\r\n        for (const button of this.buttons)\r\n        {\r\n            button.update(time);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Shuts down the event listeners for this plugin.\r\n     */\r\n    shutdown ()\r\n    {\r\n        const eventEmitter = this.systems.events;\r\n\r\n        eventEmitter.off('update', this.update, this);\r\n        eventEmitter.off('shutdown', this.shutdown, this);\r\n    }\r\n\r\n    /**\r\n     * Removes and calls `destroy` on all Stick and Button objects in this plugin.\r\n     */\r\n    destroy ()\r\n    {\r\n        this.shutdown();\r\n\r\n        for (const stick of this.sticks)\r\n        {\r\n            stick.destroy();\r\n        }\r\n\r\n        for (const button of this.buttons)\r\n        {\r\n            button.destroy();\r\n        }\r\n\r\n        this.sticks.clear();\r\n        this.buttons.clear();\r\n\r\n        this._pointerTotal = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @type {integer} VirtualJoystick.NONE\r\n */\r\nVirtualJoystick.NONE = 0;\r\n\r\n/**\r\n * @type {integer} VirtualJoystick.HORIZONTAL\r\n */\r\nVirtualJoystick.HORIZONTAL = 1;\r\n\r\n/**\r\n * @type {integer} VirtualJoystick.VERTICAL\r\n */\r\nVirtualJoystick.VERTICAL = 2;\r\n\r\n/**\r\n * @type {integer} VirtualJoystick.CIRC_BUTTON\r\n */\r\nVirtualJoystick.CIRC_BUTTON = 3;\r\n\r\n/**\r\n * @type {integer} VirtualJoystick.RECT_BUTTON\r\n */\r\nVirtualJoystick.RECT_BUTTON = 4;\r\n\r\nmodule.exports = VirtualJoystick;\r\n"]}